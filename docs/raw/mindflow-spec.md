# MindFlow: AI-First Task Manager - Complete Technical Specification & Implementation Guide

## Table of Contents
1. Product Vision & Positioning
2. Architecture Overview
3. Core Schema Design
4. OpenAI Integration Strategy
5. Tech Stack & Setup
6. Phase-by-Phase Implementation
7. Relevance Algorithm Deep Dive
8. Database Design
9. API Specification
10. Frontend Components
11. Deployment & Scaling

---

## 1. Product Vision & Positioning

### What is MindFlow?

MindFlow is an **AI-powered task manager** that operates primarily through **natural conversation**. Instead of clicking forms, users talk to GPT about their work. The AI understands context, learns habits, and suggests the next best action.

### Core Differentiators vs Competitors

| Feature | Todoist | Asana | MindFlow |
|---------|---------|-------|---------|
| Primary Interface | GUI Forms | GUI/Web | Natural Conversation |
| Task Input | Manual typing/categorization | Manual forms | "Add blog post about FastAPI due Friday" |
| What to do next? | Manual filtering | AI suggestions (basic) | Contextual AI with time/habits |
| Learning | No | Limited | Learns your patterns over time |
| Conversation | No | Limited in Pro | Central to experience |

### Target User

**You** (and professionals like you):
- Knowledge workers managing multiple projects
- Founders/CTOs juggling technical and strategic work
- People who think through speaking/typing (not clicking)
- Users who want AI that understands their context

### Business Model (Future)

- **Free tier**: 50 tasks/month, basic GPT-4 mini
- **Pro ($15/mo)**: Unlimited tasks, GPT-4 model, habit learning
- **Team ($50/mo)**: Team collaboration, shared contexts, audit logs

---

## 2. Architecture Overview

### High-Level Flow

```
USER INPUT (Natural Language)
    ↓
GPT-4 (Intent Recognition + NLU)
    ↓
FUNCTION CALLING (Create/Read/Update/Delete Tasks)
    ↓
FASTAPI BACKEND (Business Logic)
    ↓
POSTGRESQL (Data Persistence)
    ↓
RELEVANCE ENGINE (Prioritization + Ranking)
    ↓
RESPONSE GENERATION
    ↓
FRONTEND (Chat + Dashboard)
```

### Technology Stack

**Backend:**
- FastAPI (async, type-safe, OpenAPI-first)
- PostgreSQL + SQLAlchemy ORM (Supabase for managed hosting)
- Python 3.11+

**Frontend:**
- Lit 3.x (web components, minimal bundle)
- Vite (lightning-fast dev server)
- Tailwind CSS (utility-first styling)
- Vitest (unit testing)
- Bun (optional, faster Node package manager)

**AI/ML:**
- OpenAI GPT-4 API (primary)
- OpenAI Function Calling (deterministic CRUD)

**DevOps:**
- Docker + Docker Compose (local dev)
- Fly.io or Render (deployment)
- GitHub Actions (CI/CD)

**Optional Integrations (Phase 4+):**
- Google Calendar (context awareness)
- Google Tasks API (export/import)
- Slack (bot interface)
- Linear/GitHub Issues (developer sync)

---

## 3. Core Schema Design

### Task Object (PostgreSQL)

```sql
CREATE TABLE tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  -- Core Fields
  title VARCHAR(500) NOT NULL,
  description TEXT,
  status VARCHAR(50) DEFAULT 'open' CHECK (status IN ('open', 'in_progress', 'done', 'archived')),
  
  -- Temporal Fields
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  due_at TIMESTAMP,
  completed_at TIMESTAMP,
  
  -- Priority & Scoring
  priority INTEGER DEFAULT 0 RANGE (0-10),  -- User-set
  urgency_score FLOAT DEFAULT 0,            -- AI-computed (0-1)
  impact_score FLOAT DEFAULT 0,             -- AI-computed (0-1)
  effort_estimate_minutes INTEGER DEFAULT 30,
  
  -- Context & Relationships
  category VARCHAR(100),  -- e.g., "work", "personal", "learning"
  project_id UUID REFERENCES projects(id) ON DELETE SET NULL,
  parent_task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,  -- Subtask relationship
  
  -- AI & Habit Learning
  recurring_pattern VARCHAR(100),  -- "daily", "weekly", "monthly", "custom"
  recurring_until TIMESTAMP,
  tags VARCHAR(255) ARRAY,  -- Auto-generated by AI or user-set
  context_metadata JSONB,  -- Free-form data for context
  
  -- Relevance Signals
  last_reviewed_at TIMESTAMP,
  review_count INTEGER DEFAULT 0,
  completion_rate FLOAT DEFAULT 0,  -- For recurring tasks
  
  INDEX idx_user_status (user_id, status),
  INDEX idx_due_at (user_id, due_at),
  INDEX idx_urgency (user_id, urgency_score DESC)
);
```

### User Preferences (For Habit Learning)

```sql
CREATE TABLE user_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES users(id) ON DELETE CASCADE,
  
  -- Relevance Algorithm Weights
  weight_deadline FLOAT DEFAULT 0.4,
  weight_priority FLOAT DEFAULT 0.3,
  weight_impact FLOAT DEFAULT 0.15,
  weight_effort FLOAT DEFAULT 0.15,
  
  -- Time-Based Preferences
  work_start_time TIME DEFAULT '09:00',
  work_end_time TIME DEFAULT '17:00',
  timezone VARCHAR(50) DEFAULT 'UTC',
  
  -- AI Configuration
  gpt_model VARCHAR(50) DEFAULT 'gpt-4-mini',
  conversation_style VARCHAR(50) DEFAULT 'concise',  -- "verbose", "concise", "professional"
  enable_habit_learning BOOLEAN DEFAULT true,
  
  -- Push/Notification Preferences
  enable_daily_briefing BOOLEAN DEFAULT true,
  enable_suggestions BOOLEAN DEFAULT true,
  notification_time TIME DEFAULT '09:00'
);
```

### Conversation Log (For Context)

```sql
CREATE TABLE conversation_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  message_role VARCHAR(20) CHECK (message_role IN ('user', 'assistant')),
  message_content TEXT NOT NULL,
  
  -- Function calling data
  function_called VARCHAR(100),  -- e.g., "create_task", "list_tasks"
  function_arguments JSONB,
  function_result JSONB,
  
  created_at TIMESTAMP DEFAULT NOW(),
  
  INDEX idx_user_created (user_id, created_at DESC)
);
```

---

## 4. OpenAI Integration Strategy

### API Choice: Chat Completions vs Assistants API vs Responses API

**Recommendation: Chat Completions API + Function Calling**

Why?
- More control than Assistants API
- Cheaper than Assistants API
- Faster iteration than maintaining assistant on OpenAI side
- Function calling gives deterministic, auditable task operations
- Best for real-time, interactive agents

**Alternative: Responses API (if you prefer simpler state management)**
- Newer API with built-in function execution
- Handles tool loop internally
- Less developer overhead
- Might be preferable for v2 after Chat Completions MVP

### Function Schema for CRUD

```python
TASK_FUNCTIONS = [
    {
        "name": "create_task",
        "description": "Create a new task with title, description, due date, priority",
        "parameters": {
            "type": "object",
            "properties": {
                "title": {"type": "string", "description": "Task title"},
                "description": {"type": "string", "description": "Optional description"},
                "due_at": {
                    "type": "string",
                    "format": "date-time",
                    "description": "ISO 8601 datetime"
                },
                "priority": {"type": "integer", "minimum": 0, "maximum": 10},
                "category": {"type": "string"},
                "tags": {"type": "array", "items": {"type": "string"}},
                "recurring": {
                    "type": "string",
                    "enum": ["daily", "weekly", "monthly", None]
                }
            },
            "required": ["title"]
        }
    },
    {
        "name": "list_tasks",
        "description": "List user's tasks with optional filters",
        "parameters": {
            "type": "object",
            "properties": {
                "status": {
                    "type": "string",
                    "enum": ["open", "in_progress", "done"],
                    "description": "Filter by status"
                },
                "sort_by": {
                    "type": "string",
                    "enum": ["urgency", "due_date", "priority", "created_at"],
                    "default": "urgency"
                },
                "limit": {"type": "integer", "default": 10}
            }
        }
    },
    {
        "name": "update_task",
        "description": "Update an existing task",
        "parameters": {
            "type": "object",
            "properties": {
                "task_id": {"type": "string", "format": "uuid"},
                "status": {"type": "string", "enum": ["open", "in_progress", "done"]},
                "priority": {"type": "integer", "minimum": 0, "maximum": 10},
                "due_at": {"type": "string", "format": "date-time"}
            },
            "required": ["task_id"]
        }
    },
    {
        "name": "delete_task",
        "description": "Archive or delete a task",
        "parameters": {
            "type": "object",
            "properties": {
                "task_id": {"type": "string", "format": "uuid"},
                "permanently": {"type": "boolean", "default": False}
            },
            "required": ["task_id"]
        }
    },
    {
        "name": "get_next_task",
        "description": "Get the most relevant task to work on now",
        "parameters": {
            "type": "object",
            "properties": {
                "consider_deadline": {"type": "boolean", "default": True},
                "consider_effort": {"type": "boolean", "default": True}
            }
        }
    }
]
```

### System Prompt (Most Important!)

```
You are MindFlow, an AI-powered task manager. Your role is to:

1. UNDERSTAND the user's intent from natural language
   - "Add a blog post about FastAPI due Friday" → Create task with deadline
   - "What should I do next?" → Call get_next_task with current context
   - "I'm working on the podcast episode" → Update relevant task to in_progress

2. EXTRACT STRUCTURED DATA
   - Convert "due Friday" to actual datetime (in user's timezone)
   - Map vague descriptions to categories/tags
   - Infer priority from context and user history

3. DETERMINE THE RIGHT FUNCTIONS TO CALL
   - Always confirm before modifying multiple tasks
   - Use list_tasks to check for duplicates before creating
   - Provide reasoning for prioritization suggestions

4. EXPLAIN YOUR ACTIONS CLEARLY
   - "I'm creating a task: 'Polish podcast episode' due 2025-11-07, marked HIGH priority"
   - "Based on your patterns, I recommend starting with X because Y"
   - Ask clarifying questions if ambiguous

5. LEARN FROM PATTERNS
   - Remember user preferences about timing, effort, priorities
   - Reference past completed tasks for context
   - Suggest recurring tasks when you spot patterns

6. TONE & STYLE
   - Be concise but helpful
   - Use user's preferred language/formality
   - Show confidence but remain open to correction

CRITICAL RULES:
- Always use user's timezone for date/time conversions
- Never assume deadline if user doesn't specify
- Confirm before archiving/deleting tasks
- Explain relevance score components when asked
```

---

## 5. Tech Stack & Setup

### Project Structure

```
mindflow/
├── backend/
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py                 # FastAPI app entry
│   │   ├── config.py               # Settings & environment
│   │   ├── models/
│   │   │   ├── task.py             # SQLAlchemy models
│   │   │   ├── user.py
│   │   │   └── conversation.py
│   │   ├── schemas/
│   │   │   ├── task.py             # Pydantic schemas for API
│   │   │   └── user.py
│   │   ├── routes/
│   │   │   ├── chat.py             # /api/chat endpoint
│   │   │   ├── tasks.py            # /api/tasks endpoints
│   │   │   └── users.py
│   │   ├── services/
│   │   │   ├── gpt_service.py      # OpenAI integration
│   │   │   ├── relevance.py        # Task prioritization logic
│   │   │   └── task_service.py     # Business logic
│   │   ├── database/
│   │   │   ├── connection.py       # DB session management
│   │   │   └── migrations/         # Alembic migrations
│   │   ├── auth/
│   │   │   └── jwt_auth.py         # Authentication
│   │   └── utils/
│   │       ├── logger.py
│   │       └── validators.py
│   ├── requirements.txt
│   ├── pyproject.toml              # Poetry config
│   ├── Dockerfile
│   └── .env.example
│
├── frontend/
│   ├── src/
│   │   ├── index.html
│   │   ├── main.ts
│   │   ├── components/
│   │   │   ├── chat-interface.ts    # Chat UI (Lit component)
│   │   │   ├── task-list.ts         # Task list (Lit component)
│   │   │   └── dashboard.ts         # Dashboard view
│   │   ├── services/
│   │   │   └── api.ts              # API client
│   │   ├── styles/
│   │   │   └── tailwind.css
│   │   └── utils/
│   │       └── formatting.ts
│   ├── vite.config.ts
│   ├── vitest.config.ts
│   ├── tsconfig.json
│   ├── package.json
│   ├── Dockerfile
│   └── .env.example
│
├── docker-compose.yml
├── .github/
│   └── workflows/
│       └── ci.yml
└── README.md
```

### Environment Setup

```bash
# Backend
cd backend
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install -r requirements.txt

# Frontend
cd frontend
npm install  # or `bun install` if using Bun

# Database (using Supabase or local Postgres)
# See docker-compose.yml for local setup
docker-compose up -d postgres
```

---

## 6. Phase-by-Phase Implementation

### Phase 1: MVP (Weeks 1-3)
**Goal: "GPT ↔ FastAPI ↔ Sheets" but with Postgres**

**Must-have:**
- [x] FastAPI server with /api/chat endpoint
- [x] PostgreSQL with Task schema
- [x] OpenAI Chat Completions + Function calling
- [x] create_task, list_tasks, update_task functions
- [x] Minimal chat UI (Lit component)

**Timeline:**
- Week 1: Backend setup + database migrations
- Week 2: OpenAI integration + function handling
- Week 3: Frontend chat UI + basic styling

**Not yet:**
- No authentication (test user only)
- No habit learning
- No relevance ranking (just chronological)
- No persistent conversation history

**Deliverables:**
- Working chat: "Add task: write blog post, due Friday" → Creates task
- Task list: "Show my tasks" → Returns sorted list
- Basic dashboard

---

### Phase 2: Relevance Engine (Weeks 4-6)
**Goal: "What should I do next?" is intelligent**

**Must-have:**
- [x] Relevance scoring algorithm (see Section 7)
- [x] User preferences storage
- [x] Habit learning engine
- [x] get_next_task function
- [x] Conversation history logging

**Timeline:**
- Week 4: Build relevance algorithm (rule-based + ML)
- Week 5: Implement habit detection & learning
- Week 6: Polish and test ranking with real data

**Deliverables:**
- GPT suggests: "You should start with X because Y" with explainability
- User's context improves suggestions over time

---

### Phase 3: Authentication & Multi-User (Weeks 7-8)
**Goal: Production-ready, shareable**

**Must-have:**
- [x] JWT authentication
- [x] User accounts (email/password)
- [x] Data isolation (user_id everywhere)
- [x] Rate limiting
- [x] Audit logging

**Timeline:**
- Week 7: Auth system + user management
- Week 8: Security hardening + compliance

---

### Phase 4: Advanced Features (Weeks 9-12)
**Optional in MVP, but planned:**
- Google Calendar sync (context: "What's my calendar today?")
- Recurring tasks with habit detection
- Team collaboration
- Slack bot interface
- Advanced NLU (entity extraction for due dates, people, projects)
- Export to Google Tasks / Todoist

---

## 7. Relevance Algorithm Deep Dive

### "What Should I Do Next?"

This is the **core UX moment**. When user asks "What should I do next?", MindFlow must return the optimal task.

### Algorithm V1 (Rule-based, MVP)

```python
def calculate_relevance_score(task: Task, user_prefs: UserPreferences, current_time: datetime) -> float:
    """
    Calculate a relevance score for a task (0-1, higher = more relevant)
    
    Components:
    1. Urgency (deadline proximity)
    2. Priority (user-set)
    3. Impact (effort-to-value ratio)
    4. Time available (can complete before next event?)
    """
    
    # 1. URGENCY SCORE (0-1)
    if task.due_at:
        time_until_due = (task.due_at - current_time).total_seconds()
        if time_until_due < 0:  # Overdue
            urgency = 1.0
        elif time_until_due < 3600:  # < 1 hour
            urgency = 0.9
        elif time_until_due < 86400:  # < 1 day
            urgency = 0.7
        elif time_until_due < 604800:  # < 1 week
            urgency = 0.4
        else:
            urgency = 0.1
    else:
        urgency = 0.3  # No deadline = medium urgency
    
    # 2. PRIORITY SCORE (0-1)
    # User-set priority (0-10 scale) normalized to 0-1
    priority = task.priority / 10.0 if task.priority else 0.5
    
    # 3. IMPACT SCORE (0-1)
    # Simple: higher priority + longer duration = more impactful
    # Can be enhanced with project weight, user tags, etc.
    impact_raw = (task.priority / 10.0) * (1.0 - (task.effort_estimate_minutes / 480.0))
    impact = min(impact_raw, 1.0)
    
    # 4. CONTEXT SCORE (0-1)
    # If task is explicitly marked "in_progress", boost it
    context_boost = 1.2 if task.status == "in_progress" else 1.0
    
    # 5. COMBINED RELEVANCE
    weights = {
        'urgency': user_prefs.weight_deadline,      # 0.4 (default)
        'priority': user_prefs.weight_priority,    # 0.3
        'impact': user_prefs.weight_impact,        # 0.15
        'effort': user_prefs.weight_effort         # 0.15
    }
    
    # Effort consideration: prefer shorter tasks when urgency is high
    effort_score = 1.0 - min(task.effort_estimate_minutes / 120.0, 1.0)  # Prefer < 2 hours
    
    relevance = (
        weights['urgency'] * urgency +
        weights['priority'] * priority +
        weights['impact'] * impact +
        weights['effort'] * effort_score
    ) * context_boost
    
    return min(relevance, 1.0)
```

### Algorithm V2 (ML Enhancement, Phase 3+)

Use user's historical completion patterns to refine weights:
- If user always completes high-priority tasks → increase weight_priority
- If user often completes short tasks → increase weight_effort
- If user tends to miss deadlines → increase weight_deadline

```python
def learn_user_preferences(user_id: UUID, completed_tasks: List[Task]) -> UserPreferences:
    """
    Analyze completed tasks to infer user's natural preference weights
    """
    if len(completed_tasks) < 10:
        return default_preferences()  # Not enough data
    
    # Analyze patterns
    high_priority_completion_rate = sum(
        1 for t in completed_tasks if t.priority >= 7
    ) / len(completed_tasks)
    
    short_task_completion_rate = sum(
        1 for t in completed_tasks if t.effort_estimate_minutes <= 30
    ) / len(completed_tasks)
    
    on_time_completion_rate = sum(
        1 for t in completed_tasks if t.completed_at <= t.due_at
    ) / len([t for t in completed_tasks if t.due_at])
    
    # Adjust weights based on patterns
    prefs = UserPreferences()
    prefs.weight_priority = 0.3 + (high_priority_completion_rate * 0.2)
    prefs.weight_effort = 0.15 + (short_task_completion_rate * 0.15)
    prefs.weight_deadline = 0.4 + (on_time_completion_rate * 0.1)
    
    return prefs
```

### Explainability (Critical for Trust)

When returning "next task", **always explain why**:

```python
def explain_relevance(task: Task, scores: Dict[str, float]) -> str:
    """
    Generate natural language explanation of why this task is recommended
    """
    explanations = []
    
    if scores['urgency'] > 0.7:
        due_in = task.due_at - datetime.now()
        if due_in.days == 0:
            explanations.append(f"It's due TODAY")
        else:
            explanations.append(f"Due in {due_in.days} days")
    
    if scores['priority'] > 0.7:
        explanations.append(f"High priority")
    
    if scores['impact'] > 0.7:
        explanations.append(f"High impact")
    
    if scores['effort'] > 0.7:
        explanations.append(f"Quick to complete ({task.effort_estimate_minutes}min)")
    
    return "I recommend this because: " + ", ".join(explanations)
```

---

## 8. Database Design

### Migrations (Using Alembic)

```bash
# Create initial migration
alembic init migrations
alembic revision --autogenerate -m "Initial schema"
alembic upgrade head
```

### Key Indexes for Performance

```sql
-- Task lookup by user + status (most common query)
CREATE INDEX idx_tasks_user_status ON tasks(user_id, status);

-- Task lookup by deadline (for relevance sorting)
CREATE INDEX idx_tasks_user_due ON tasks(user_id, due_at DESC);

-- Task lookup by relevance score (for "next task" queries)
CREATE INDEX idx_tasks_user_urgency ON tasks(user_id, urgency_score DESC);

-- Conversation history lookup
CREATE INDEX idx_conversations_user ON conversation_logs(user_id, created_at DESC);
```

---

## 9. API Specification

### Chat Endpoint

```
POST /api/chat
Content-Type: application/json

{
  "message": "Add a blog post about FastAPI due Friday",
  "timezone": "America/New_York"  // For date parsing
}

Response:
{
  "id": "conv-12345",
  "response": "I've created a task 'Blog post about FastAPI' due 2025-11-07 at 5:00 PM. Is this correct?",
  "action": {
    "type": "task_created",
    "task_id": "task-xyz"
  },
  "next_task_suggestion": {
    "task": {...},
    "reason": "Due today and high priority"
  }
}
```

### Task Endpoints

```
GET /api/tasks?status=open&sort=urgency
GET /api/tasks/:id
POST /api/tasks
PUT /api/tasks/:id
DELETE /api/tasks/:id

POST /api/tasks/next  # Get the most relevant task to work on now
```

---

## 10. Frontend Components (Lit 3)

### Chat Interface Component

```typescript
// src/components/chat-interface.ts
import { LitElement, html, css } from 'lit';
import { customElement, state } from 'lit/decorators.js';

@customElement('chat-interface')
export class ChatInterface extends LitElement {
  @state() messages: Array<{role: 'user' | 'assistant', content: string}> = [];
  @state() loading = false;
  @state() inputValue = '';

  static styles = css`
    :host {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    
    .messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .message {
      max-width: 70%;
      padding: 12px 16px;
      border-radius: 12px;
      word-wrap: break-word;
    }
    
    .user {
      align-self: flex-end;
      background: #667eea;
      color: white;
    }
    
    .assistant {
      align-self: flex-start;
      background: white;
      color: #333;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .input-area {
      padding: 20px;
      background: white;
      display: flex;
      gap: 12px;
    }
    
    input {
      flex: 1;
      padding: 12px 16px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 1rem;
    }
    
    button {
      padding: 12px 24px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
  `;

  private async sendMessage() {
    if (!this.inputValue.trim()) return;
    
    const userMessage = this.inputValue;
    this.messages = [...this.messages, { role: 'user', content: userMessage }];
    this.inputValue = '';
    this.loading = true;
    
    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: userMessage, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone })
      });
      
      const data = await response.json();
      this.messages = [...this.messages, { role: 'assistant', content: data.response }];
    } catch (error) {
      console.error('Chat error:', error);
    } finally {
      this.loading = false;
    }
  }

  render() {
    return html`
      <div class="messages">
        ${this.messages.map(msg => html`
          <div class="message ${msg.role}">
            ${msg.content}
          </div>
        `)}
      </div>
      
      <div class="input-area">
        <input
          type="text"
          placeholder="Tell me what to do..."
          .value=${this.inputValue}
          @input=${(e: any) => this.inputValue = e.target.value}
          @keydown=${(e: KeyboardEvent) => e.key === 'Enter' && this.sendMessage()}
        />
        <button @click=${() => this.sendMessage()} ?disabled=${this.loading}>
          ${this.loading ? 'Sending...' : 'Send'}
        </button>
      </div>
    `;
  }
}
```

### Task Dashboard

```typescript
// src/components/task-list.ts
@customElement('task-list')
export class TaskList extends LitElement {
  @state() tasks: Task[] = [];
  @state() nextTask: Task | null = null;

  async connectedCallback() {
    super.connectedCallback();
    await this.loadTasks();
  }

  private async loadTasks() {
    const response = await fetch('/api/tasks?sort=urgency');
    this.tasks = await response.json();
    
    const nextResponse = await fetch('/api/tasks/next');
    this.nextTask = await nextResponse.json();
  }

  render() {
    return html`
      <div class="dashboard">
        ${this.nextTask ? html`
          <div class="next-task-card">
            <h2>What you should do now</h2>
            <div class="task-item">
              <h3>${this.nextTask.title}</h3>
              <p>${this.nextTask.description}</p>
              <span class="due">${this.formatDate(this.nextTask.due_at)}</span>
            </div>
          </div>
        ` : ''}
        
        <div class="task-list">
          ${this.tasks.map(task => html`
            <div class="task-item">
              <input type="checkbox" @change=${() => this.markDone(task.id)} />
              <div>
                <h4>${task.title}</h4>
                <p>${task.description}</p>
              </div>
              <span class="priority">${task.priority}/10</span>
            </div>
          `)}
        </div>
      </div>
    `;
  }

  private async markDone(taskId: string) {
    await fetch(`/api/tasks/${taskId}`, {
      method: 'PUT',
      body: JSON.stringify({ status: 'done' })
    });
    await this.loadTasks();
  }

  private formatDate(date: string) {
    return new Date(date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }
}
```

---

## 11. Deployment & Scaling

### Local Development (Docker Compose)

```yaml
# docker-compose.yml
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: mindflow
      POSTGRES_PASSWORD: dev_password
      POSTGRES_DB: mindflow_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql://mindflow:dev_password@postgres:5432/mindflow_db
      OPENAI_API_KEY: ${OPENAI_API_KEY}
    depends_on:
      - postgres
    volumes:
      - ./backend:/app

  frontend:
    build: ./frontend
    ports:
      - "5173:5173"
    volumes:
      - ./frontend:/app

volumes:
  postgres_data:
```

### Production Deployment (Fly.io)

```bash
# Backend
fly deploy --config ./backend/fly.toml

# Frontend
fly deploy --config ./frontend/fly.toml
```

### Scaling Considerations

1. **Database**: Use Supabase (PostgreSQL managed) → scales automatically
2. **API**: FastAPI on Fly → horizontal scaling via multiple instances
3. **OpenAI**: Leverage rate limiting + caching of common patterns
4. **Frontend**: Static site on CDN (Cloudflare, Vercel)

---

## Getting Started (Week 1)

### Step 1: Clone & Setup

```bash
git clone https://github.com/yourusername/mindflow.git
cd mindflow

# Backend
cd backend
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt

# Frontend
cd ../frontend
npm install
```

### Step 2: Environment Variables

```bash
# backend/.env
DATABASE_URL=postgresql://mindflow:password@localhost:5432/mindflow_db
OPENAI_API_KEY=sk-...
JWT_SECRET=your_secret_key

# frontend/.env
VITE_API_URL=http://localhost:8000
```

### Step 3: Database & Run

```bash
docker-compose up -d postgres
cd backend
alembic upgrade head
python -m uvicorn app.main:app --reload

# In another terminal
cd frontend
npm run dev
```

Visit `http://localhost:5173` → Start chatting!

---

## Key Decisions Made

1. **Chat Completions + Function Calling**: More control than Assistants API, easier to test
2. **PostgreSQL**: Relational data (tasks, users) + JSONB for flexibility
3. **Lit 3**: Minimal, fast, web components standard
4. **Rule-based Relevance V1**: Fast, interpretable, AI-explainable
5. **No auth in MVP**: Focus on core chat experience first
6. **Supabase for production**: Managed Postgres + auth + hosting

---

## Success Metrics (Phase 1 Complete)

- ✅ Can create tasks via natural language
- ✅ Can list tasks with relevance sorting
- ✅ Can get "next task" recommendation
- ✅ Chat feels natural and responsive
- ✅ Zero manual clicking (all via conversation)

---

## Next Steps After MVP

1. **User testing** with 5-10 beta users
2. **Habit learning**: Detect patterns (recurring tasks, optimal times)
3. **Calendar sync**: "What's on my plate today?" with Google Calendar context
4. **Export**: Push completed tasks to Todoist/Google Tasks
5. **Monetization**: Add auth, create Pro tier, ship to users